# ConvexHull
Repository for ConvexHull project for CS375


Our project this week was to examine the problem of the convex hull identification and how parallelizable it is. The convex hull of a set S of points is the collection of the smallest convex set containing S. A set is said to be convex if for any two points in the set, the line between them is also in that set. The convex hull problem is well known as an interesting computational geometry problem, which is mostly due to its vast number of applications. 

There are a variety of known algorithms to solve the convex hull problem, at a variety of different space and time efficiencies. 

To start, we worked on a sequential method and made sure that our code could handle a variety of inputs, including negative and positive x and y values. Our sequential algorithm was an original implementation of QuickHull, which is one of the fastest known methods for solving a convex hull problem. The time complexity of this implementation is widely accepted to be O(n log n) on average cases.

The first improvement we did was an implementation using parallel Streams. We were able to acheive a significant speedup using this method.

The second improvement we did was an implementation that utilized threading. Sequentially, QuickHull algorithm identifies a segment and then finds the points on either side of the segment; from each groups of points, the point with the furthest distance from the line is identified and any points inside the triangle formed by the endpoints of the original line segment and the new point are thrown out. Then, each of the two sides of the triangle are used as new line segments for which to identify new points, and so on, until only the maximum points have been added to a list of points that are in the convex hull. Using threading, this method can be improved by using separate threads for recursive calls. For example, after identifying the two sets of points to the left and right of the original line segment, pass each set of points to individual threads to recursively examine. Depending on how many threads are available to the user, the actual improvement that this algorithm can offer will differ. For example, if the user has access to more than two threads, then they can pass the original two sets of left and right points to two threads, and then pass the recursive calls of the results of these threads to additional threads. Our resources for this project somewhat limited the speedup of this algorithm, because our laptops only had 4 or less threads available to the program. Therefore, the speedup of this algorithm is to divide amount of time required to sequentially identify the points in the convex hull by the number of t threads available to the user. This means that the threading process does not change the determining term in the time complexity equation, but rather reduces the time complexity by a factor. 

The last improvement we did was an implementation that utilized a fork/join framework. 
